<?xml version="1.0" encoding="UTF-8"?>
<node name="groupByGene" label="Group By Gene" 
	description="Group VCF by Gene"
	generate-model='true'
	xmlns:xi="http://www.w3.org/2001/XInclude"
	>
   <xi:include href="inport.vcf.xml"/>
   <outPort name="output" columns-at-runtime="true"/>
  
	<property type="column" name="vcfInput" label="VCF path" description="VCF files" data-type="string"  port="input"/>
    <property type="string" name="userInfoGene" label="custom INFO field containing a gene name"  default=""/>
  <code>
  	<import>
import htsjdk.samtools.util.CloserUtil;
import java.io.BufferedReader;
import java.io.File;
import java.util.Collections;
import java.util.regex.Pattern;
import com.github.lindenb.jvarkit.io.IOUtils;
import com.github.lindenb.jvarkit.tools.groupbygene.GroupByGene;

  	</import>
   <body><![CDATA[
   
 	@Override
    protected BufferedDataTable[] execute(
    		final BufferedDataTable[] inData,
            final ExecutionContext exec
            ) throws Exception
		{
		BufferedDataContainer out_container=null;
		BufferedReader r=null;
		RowIterator rowiterator=null;
		String vcfFile=null;
		File tsvTable=null;
		try
	    	{
			BufferedDataTable inTable=inData[0];
	        int inUriIndex = this.findVcfInputRequiredColumnIndex(inTable.getDataTableSpec());
	        double total=inTable.getRowCount();
	        int nRow = 0;
	        
        	rowiterator=inTable.iterator();
        	while(rowiterator.hasNext())
        		{
        		++nRow;
        		DataRow row=rowiterator.next();
                DataCell cell =row.getCell(inUriIndex);

	            if(cell.isMissing())
	            	{
	            	getLogger().warn("Missing cells in "+getNodeName());
	            	continue;
	            	}
	            if(!cell.getType().equals(StringCell.TYPE))
	            	{
	            	getLogger().error("not a StringCell type in "+cell);
	            	continue;
	            	}
                String uri = StringCell.class.cast(cell).getStringValue();
                if(uri.isEmpty())
                	{
	            	getLogger().error("Empty uri");
	            	continue;
                	}
                if(vcfFile!=null && !vcfFile.equals(uri))
                	{
                	throw new RuntimeException("This node only accept ONE row but found "+vcfFile+" and "+uri);
                	}
                vcfFile=uri;
        		exec.checkCanceled();
            	exec.setProgress(nRow/total,"Reading");
        		}
        	if(vcfFile==null)
        		{
        		getLogger().warn("No VCF input");
        		return new BufferedDataTable[]{null};
        		}
        	else
        		{
        		getLogger().info("Reading "+vcfFile);
        		GroupByGene command=new GroupByGene();
        		tsvTable = new File(this.getNodeWorkingDirectory(),md5(vcfFile)+".tsv");
        		tsvTable.getParentFile().mkdirs();
        		command.setOutputFile(tsvTable);
        		command.addTmpDirectory(this.getNodeWorkingDirectory());
        		for(String tag: this.getPropertyUserInfoGeneValue().split("[\n \t]"))
        			{
        			if(tag.isEmpty()) continue;
        			command.addUserGeneTag(tag);
        			}
        		command.initializeKnime();
        		if(command.executeKnime(Collections.singletonList(vcfFile))!=0)
        			{
        			throw new RuntimeException("groupby gene failed");
        			}
        		command.disposeKnime();
        		
        		getLogger().info("Reading "+tsvTable);
        		r = IOUtils.openFileForBufferedReading(tsvTable);
        		String line=r.readLine();
        		if(line==null || line.trim().isEmpty())
        			{
        			r.close();
        			throw new RuntimeException("first line of output is empty");
        			}
        		Pattern tab=Pattern.compile("[\t]");
        		String tokens[]=tab.split(line);
        		DataColumnSpec colspecs[]=new DataColumnSpec[tokens.length];
        		for(int i=0;i< tokens.length;++i)
        			{
        			if(tokens[i].startsWith("#")) tokens[i]=tokens[i].substring(1);
        			switch(i)
        				{
        				case 0: case 3: case 4:
        					colspecs[i] = new  DataColumnSpecCreator(tokens[i],StringCell.TYPE).createSpec();
        					break;
        				default:
        					colspecs[i] = new  DataColumnSpecCreator(tokens[i],IntCell.TYPE).createSpec();
        					break;
        				}
        			}
        		nRow=0;
        		out_container = exec.createDataContainer(new DataTableSpec(colspecs));
        		while((line=r.readLine())!=null)
        			{
        			tokens=tab.split(line);
        			if(tokens.length!=colspecs.length)
        				{
        				throw new RuntimeException("inconsitent number of columns");
        				}
        			++nRow;
        			DataCell cells[]=new DataCell[tokens.length];
        			for(int i=0;i< tokens.length;++i)
	        			{
	        			switch(i)
		    				{
		    				case 0: case 3: case 4:
		    					cells[i] = new  StringCell(tokens[i]);
		    					break;
		    				default:
		    					cells[i] = new IntCell(Integer.parseInt(tokens[i]));
		    					break;
		    				}
	        			}
        			out_container.addRowToTable(new DefaultRow(RowKey.createRowKey(nRow), cells));
        			}
        		r.close(); r=null;
        		tsvTable.delete();
    	        /* create and fill array to be returned */
            	out_container.close();
                BufferedDataTable out0 = out_container.getTable();
                out_container=null;
                return new BufferedDataTable[]{out0};        		
        		}
        	
	    	}
		catch(Exception err)
			{
			getLogger().error("Boum", err);
			err.printStackTrace();
			throw err;
			}
		finally
			{
			if(tsvTable!=null) tsvTable.delete();
			CloserUtil.close(out_container);
			}
		}
  
   
   ]]></body>
  </code>
</node>

