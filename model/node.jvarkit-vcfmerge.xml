<?xml version="1.0" encoding="UTF-8"?>
<node name="vcfMerge" label="Merge VCF" 
	description="Merge VCF files"
	generate-model='true'
	xmlns:xi="http://www.w3.org/2001/XInclude"
	>
   <xi:include href="inport.vcf.xml"/>
   <xi:include href="outport.vcf_count.xml"/>

 <property type="column" name="vcfInput" label="VCF path" description="VCF files" data-type="string"  port="input"/>
  <property type="bool" name="vcfSorted" label="sorted VCF" description="All VCFs are known to be sorted " default="false"/>
 
  <description>
     <xi:include href="footer.html" xpointer="xpointer(/div/*)" parse="xml" />
  </description>
  
  <code>
  <import>
import htsjdk.samtools.util.CloserUtil;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import com.github.lindenb.jvarkit.tools.vcfmerge.VCFMerge2;
  </import>
  <body>  
  
	
	/* @inheritDoc */
	@Override
    protected BufferedDataTable[] execute(
    		final BufferedDataTable[] inData,
            final ExecutionContext exec
            ) throws Exception
			{
			BufferedDataContainer out_container =null;
			File mergedFile= null;
			 RowIterator rowiterator=null;
			try
		    	{
				BufferedDataTable inTable=inData[0];
		        int inUriIndex = this.findVcfInputRequiredColumnIndex(inTable.getDataTableSpec());
				Set&lt;String&gt; vcffiles = new HashSet&lt;String&gt;(inTable.getRowCount()); 
		        double total=inTable.getRowCount();
		        long nRow = 0L;
		       
		       
		        
	        	rowiterator=inTable.iterator();
	        	while(rowiterator.hasNext())
	        		{
	        		++nRow;
	        		DataRow row=rowiterator.next();
	                DataCell cell =row.getCell(inUriIndex);

		            if(cell.isMissing())
		            	{
		            	getLogger().warn("Missing cells in "+getNodeName());
		            	continue;
		            	}
		            if(!cell.getType().equals(StringCell.TYPE))
		            	{
		            	getLogger().error("not a StringCell type in "+cell);
		            	continue;
		            	}
	                String uri = StringCell.class.cast(cell).getStringValue();
	                if(uri.isEmpty())
	                	{
		            	getLogger().error("Empty uri");
		            	continue;
	                	}
	                vcffiles.add(uri);
	        		exec.checkCanceled();
	            	exec.setProgress(nRow/total,"Extracting vcfMerge....");
	        		}
	        		
	        	DataTableSpec dataOutSpec = this.createOutTableSpec0();
	        	out_container = exec.createDataContainer(dataOutSpec);;
	        	
	        	if(	!vcffiles.isEmpty())
			    	{
			    	File nodeDir=this.getKnime5BiNodeWorkingDirectory();
			    	nodeDir.mkdirs();
			    	mergedFile = new File(nodeDir,md5(getNodeUniqId())+".vcf.gz");
			    	VCFMerge2 vcfMerge2=new VCFMerge2();
			    	
			    	vcfMerge2.addTmpDirectory(this.getKnime5BiNodeWorkingDirectory());
			    	vcfMerge2.setOutputFile(mergedFile);
			    	vcfMerge2.setFilesAreSorted(this.isPropertyVcfSortedValue());
			    	if(vcfMerge2.initializeKnime()!=0)
			    		{
			    		throw new RuntimeException("Cannot initialize knime");
			    		}
			    	
			    	if( vcfMerge2.executeKnime(new ArrayList&lt;String&gt;(vcffiles))!=0)
			    		{
			    		mergedFile.delete();
			    		throw new RuntimeException("Merge failed");
			    		}
			    	
			    	
			    	
			    	
			    	 out_container.addRowToTable(new DefaultRow(
				            	RowKey.createRowKey(1),
				            	createDataCellsForOutTableSpec0(
				            			mergedFile.getPath(),
				            			vcfMerge2.getCountMergedVariants()
				            			)
				            	));
				      }
		        /* create and fill array to be returned */
	        	out_container.close();
	            BufferedDataTable out0 = out_container.getTable();
	            out_container=null;
	            return new BufferedDataTable[]{out0};
		    	}
			catch(Exception err)
				{
				if(mergedFile!=null) mergedFile.delete();
				getLogger().error("Boum", err);
				err.printStackTrace();
				throw err;
				}
			finally
				{
				CloserUtil.close(out_container);
				}
			}
  </body>
  
  </code>
  
  
</node>

