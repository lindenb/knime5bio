<?xml version="1.0" encoding="UTF-8"?>
<node name="vcf2table" label="VCF To KnimeTable" 
	xmlns:xi="http://www.w3.org/2001/XInclude"
	>

  <description>
     <h3>Motivation</h3>
     <p>Load one VCF in a KNIME table.</p>
     <xi:include href="footer.html" xpointer="xpointer(/div/*)" parse="xml" />
  </description>


   <xi:include href="inport.vcf.xml"/>
   <outPort name="output" columns-at-runtime="true">
   </outPort>
  
  <property type="column" name="vcfInput" label="VCF path" description="VCF files" data-type="string"  port="input">
  </property>
  <property type="bool" name="includeGenotypes" label="Include Genotypes"  default="true">
  </property>
 
  <code>
  <import>

import htsjdk.samtools.util.CloserUtil;
import htsjdk.variant.variantcontext.Genotype;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.VariantContextBuilder;
import htsjdk.variant.vcf.VCFEncoder;
import htsjdk.variant.vcf.VCFFilterHeaderLine;
import htsjdk.variant.vcf.VCFFormatHeaderLine;
import htsjdk.variant.vcf.VCFHeader;
import htsjdk.variant.vcf.VCFInfoHeaderLine;


import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import com.github.lindenb.jvarkit.util.picard.SAMSequenceDictionaryProgress;
import com.github.lindenb.jvarkit.util.vcf.VCFUtils;
import com.github.lindenb.jvarkit.util.vcf.VcfIterator;


  </import>

<body>

	/** create a TableDataSpec from a VCF header */
	private DataTableSpec createDataTableSpecFromVcfHeader(final VCFHeader header)
		{
		DataColumnSpecCreator dcsc=null;
		Map&lt;String,String&gt; props=new HashMap&lt;String,String&gt;();
		List&lt;String&gt; samples= header.getSampleNamesInOrder();
		if(samples==null) samples = java.util.Collections.emptyList();
		DataColumnSpec cols[]=null;
		if(samples.isEmpty())
			{
			cols=new DataColumnSpec[8];
			}
		else
			{
			cols=new DataColumnSpec[9+samples.size()];
			}
		cols[0] = new DataColumnSpecCreator("CHROM",StringCell.TYPE).createSpec();
		cols[1] = new DataColumnSpecCreator("POS",IntCell.TYPE).createSpec();
		cols[2] = new DataColumnSpecCreator("ID",StringCell.TYPE).createSpec();
		cols[3] = new DataColumnSpecCreator("REF",StringCell.TYPE).createSpec();
		cols[4] = new DataColumnSpecCreator("ALT",StringCell.TYPE).createSpec();
		cols[5] = new DataColumnSpecCreator("QUAL",DoubleCell.TYPE).createSpec();
		
		//FILTER
		props=new HashMap&lt;String,String&gt;();
		for(VCFFilterHeaderLine h:header.getFilterLines())
			{
			props.put(h.getKey(), h.getValue());
			}
		dcsc = new DataColumnSpecCreator("FILTER",StringCell.TYPE);
		if(!props.isEmpty()) dcsc.setProperties(new DataColumnProperties(props));
		cols[6] = dcsc.createSpec();
		
		//INFO
		props=new HashMap&lt;String,String&gt;();
		for(VCFInfoHeaderLine h:header.getInfoHeaderLines())
			{
			props.put(h.getKey(), h.getDescription());
			}
		dcsc = new DataColumnSpecCreator("INFO",StringCell.TYPE);
		cols[7] = dcsc.createSpec();
		
		
		//FORMAT
		props=new HashMap&lt;String,String&gt;();
		for(VCFFormatHeaderLine h:header.getFormatHeaderLines())
			{
			props.put(h.getKey(), h.getDescription());
			}
		if(!samples.isEmpty())
			{
			dcsc = new DataColumnSpecCreator("FORMAT",StringCell.TYPE);
			cols[8] = dcsc.createSpec();
			for(int i=0;i &lt; samples.size();++i)
				{
				cols[9+i] = new DataColumnSpecCreator(samples.get(i),StringCell.TYPE).createSpec();
				}
			}
		return new DataTableSpec(cols);
		}
	
	private final Pattern _tab=Pattern.compile("[\t]");
	private  DataCell[] createDataRowFromVariantContext(final VCFEncoder vcfEncoder,final VariantContext ctx)
		{
		String cols[]=_tab.split(vcfEncoder.encode(ctx));
		DataCell cells[]=null;
		if(isPropertyIncludeGenotypesValue())
			{
			cells=new DataCell[9+ ctx.getNSamples()];
			}
		else
			{
			cells=new DataCell[8];
			}
		cells[0]= new StringCell(ctx.getContig());
		cells[1]= new IntCell(ctx.getStart());
		cells[2]= (!ctx.hasID()?DataType.getMissingCell():new StringCell(ctx.getID()));
		cells[3]= new StringCell(ctx.getReference().getDisplayString());
		
		if(!ctx.isVariant())
			{
			cells[4] = DataType.getMissingCell();
			}
		else
			{
			cells[4] = new StringCell(cols[4]);
			}
		if(!ctx.hasLog10PError())
			{
			cells[5] = DataType.getMissingCell();
			}
		else
			{
			cells[5] = new DoubleCell(ctx.getPhredScaledQual());
			}
		
		if(!ctx.isFiltered())
			{
			cells[6] = DataType.getMissingCell();
			}
		else
			{
			cells[6] = new StringCell(cols[6]);
			}
		cells[7] = new StringCell(cols[7]);
		
		if(isPropertyIncludeGenotypesValue())
			{
			cells[8] = new StringCell(cols[8]);
			for(int i=0;i&lt; ctx.getNSamples();++i)
				{
				cells[9+i]= (!ctx.getGenotype(i).isAvailable()?
						 DataType.getMissingCell():
						 new StringCell(cols[9+i]))
						 ;
				}
			}
		return cells;
		}


	
	/* @inheritDoc */
	@Override
    protected BufferedDataTable[] execute(
    		final BufferedDataTable[] inData,
            final ExecutionContext exec
            ) throws Exception
			{
			BufferedDataContainer out_container =null;
			VcfIterator vcfIn=null;
			RowIterator rowiterator=null;
			String vcfFile=null;
			try
		    	{
				BufferedDataTable inTable=inData[0];
		        int inUriIndex = this.findVcfInputRequiredColumnIndex(inTable.getDataTableSpec());
		        double total=inTable.getRowCount();
		        int nRow = 0;
		        
	        	rowiterator=inTable.iterator();
	        	while(rowiterator.hasNext())
	        		{
	        		++nRow;
	        		DataRow row=rowiterator.next();
	                DataCell cell =row.getCell(inUriIndex);

		            if(cell.isMissing())
		            	{
		            	getLogger().warn("Missing cells in "+getNodeName());
		            	continue;
		            	}
		            if(!cell.getType().equals(StringCell.TYPE))
		            	{
		            	getLogger().error("not a StringCell type in "+cell);
		            	continue;
		            	}
	                String uri = StringCell.class.cast(cell).getStringValue();
	                if(uri.isEmpty())
	                	{
		            	getLogger().error("Empty uri");
		            	continue;
	                	}
	                if(vcfFile!=null &amp;&amp; !vcfFile.equals(uri))
	                	{
	                	throw new RuntimeException("This node only accept ONE row but found "+vcfFile+" and "+uri);
	                	}
	                vcfFile=uri;
	        		exec.checkCanceled();
	            	exec.setProgress(nRow/total,"Reading");
	        		}
	        	DataTableSpec dataOutSpec=null;
	        	if(vcfFile==null)
	        		{
	        		getLogger().warn("No VCF input");
	        		VCFHeader header=new VCFHeader();
	        		dataOutSpec = createDataTableSpecFromVcfHeader(header);
	        		out_container = exec.createDataContainer(dataOutSpec);;
	        		}
	        	else
	        		{
	        		nRow=0;
	        		vcfIn=VCFUtils.createVcfIterator(vcfFile);
	        		VCFHeader header=vcfIn.getHeader();
	        		VCFHeader header2=(isPropertyIncludeGenotypesValue()?header:
	        			new VCFHeader(header.getMetaDataInInputOrder())
	        				);
	        		dataOutSpec = createDataTableSpecFromVcfHeader(header2);
	        		out_container = exec.createDataContainer(dataOutSpec);
	        		VCFEncoder vcfEncoder=new VCFEncoder(header2, false, true);
	        		SAMSequenceDictionaryProgress progress=new SAMSequenceDictionaryProgress(header.getSequenceDictionary());
	        		while(vcfIn.hasNext())
	        			{
	        			++nRow;
	        			VariantContext ctx= progress.watch(vcfIn.next());
	        			if(!isPropertyIncludeGenotypesValue())
	        				{
	        				VariantContextBuilder vcb=new VariantContextBuilder(ctx);
	        				vcb.genotypes(new Genotype[0]);
	        				ctx=vcb.make();
	        				}
	        			DataCell cells[]=createDataRowFromVariantContext(vcfEncoder, ctx);
	        			out_container.addRowToTable(new DefaultRow(RowKey.createRowKey(nRow), cells));
	        			
	        			exec.checkCanceled();
		            	exec.setMessage("Variants N="+nRow);
	        			}
	        		
	        		progress.finish();
	        		}
	        	
		        /* create and fill array to be returned */
	        	out_container.close();
	            BufferedDataTable out0 = out_container.getTable();
	            out_container=null;
	            return new BufferedDataTable[]{out0};
		    	}
			catch(Exception err)
				{
				getLogger().error("Boum", err);
				err.printStackTrace();
				throw err;
				}
			finally
				{
				CloserUtil.close(out_container);
				}
			}
</body>
</code>
 
</node>

