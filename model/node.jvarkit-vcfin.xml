<?xml version="1.0" encoding="UTF-8"?>
<node name="vcfIn"
	label="VCF Intersection" 
	generate-model='true'
	xmlns:xi="http://www.w3.org/2001/XInclude"
	>
	
  <description>
     <h3>Motivation</h3>
     <p>DEPRECATED: use the vcf-join node.</p>
     <xi:include href="footer.html" xpointer="xpointer(/div/*)" parse="xml" />
  </description>
	

   <xi:include href="inport.vcf.xml"/>
   <xi:include href="outport.vcf_count.xml"/>

  
  <property type="column" name="vcfUserInput" label="VCF User path" description="User VCF files" data-type="string"  port="input"/>
  <property type="column" name="vcfDataInput" label="VCF Database path" description="Database VCF files" data-type="string"  port="input"/>
  <property type="bool" name="tabix" label="Database is indexed with tabix"  default="false"/>
  <property type="bool" name="allAltAlleles" label="picky about ALT" description="ALL user ALT alleles must be present in VCF database"  default="false"/>
  <property type="bool" name="inverse" label="inverse" description="find user vcf NOT in database VCF"  default="false"/>

<code><body> <![CDATA[


/* @inheritDoc */
	@Override
	protected BufferedDataTable[] execute(
			BufferedDataTable[] inData,
			final ExecutionContext exec) throws Exception
			{
		if(inData.length!=1)
		{
			throw new RuntimeException("Boum");
		}
		com.github.lindenb.jvarkit.tools.vcfcmp.VcfIn instance=null;

		org.knime.core.data.container.CloseableRowIterator iter=null;
		BufferedDataTable inTable=inData[0];
		DataTableSpec dataOutSpec = this.createOutTableSpec0();
		BufferedDataContainer out_container = null;
		int inUserVcfIndex = this.findVcfUserInputRequiredColumnIndex(inTable.getDataTableSpec());
		int inDataVcfIndex = this.findVcfDataInputRequiredColumnIndex(inTable.getDataTableSpec());

		try {
			instance= new com.github.lindenb.jvarkit.tools.vcfcmp.VcfIn();


			instance.setDatabaseIsTabix(super.isPropertyAllAltAllelesValue());
			instance.setUserAltInDatabase(super.isPropertyAllAltAllelesValue());
			instance.setInverse(super.isPropertyInverseValue());


			out_container = exec.createDataContainer(dataOutSpec);
			int nRows=0;
			double total=inTable.getRowCount();
			iter = inTable.iterator();
			while(iter.hasNext())
			{
				DataRow row=iter.next();
				++nRows;
				String uris[]=new String[]{null,null};
				for(int i=0;i< 2;++i)
					{
					DataCell cell =row.getCell(i==0?inDataVcfIndex:inUserVcfIndex);
	
					if(cell.isMissing())
						{
						getLogger().warn("Missing cells in "+getNodeName());
						continue;
						}
					if(!cell.getType().equals(StringCell.TYPE))
						{
						getLogger().error("not a StringCell type in "+cell);
						continue;
						}
					String uri = StringCell.class.cast(cell).getStringValue();
					if(uri.isEmpty())
						{
						getLogger().error("Empty uri");
						continue;
						}
					uris[i]=uri;
					}
				if(uris[0]==null || uris[1]==null  )
					{
					continue;
					}
				
				/* create output file */
				java.io.File fileout = createFileForWriting(uris[0]+"."+md5(uris[1]),".vcf.gz");
				/* create parent directory if it doesn't exist */
				if(fileout.getParentFile()!=null)
					{
					fileout.getParentFile().mkdirs();
					}
				instance.setOutputFile(fileout);

				
				if(instance.executeKnime(java.util.Arrays.asList(uris))!=0)
				{
					fileout.delete();
					throw new RuntimeException("error during processing"+getNodeName());
				}


				out_container.addRowToTable(new DefaultRow(
						RowKey.createRowKey(nRows),
						createDataCellsForOutTableSpec0(
								fileout.getPath(),
								instance.getVariantCount()
								)
						));


				exec.checkCanceled();
				exec.setProgress(nRows/total);
			}
			iter.close();
			iter=null;
			out_container.close();
			BufferedDataTable out0 = out_container.getTable();
			out_container=null;
			return new BufferedDataTable[]{out0};
		}
		finally
				{
					htsjdk.samtools.util.CloserUtil.close(iter);
					htsjdk.samtools.util.CloserUtil.close(out_container);
				}
			}

]]></body></code>

</node>

