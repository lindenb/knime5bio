<?xml version="1.0" encoding="UTF-8"?>
<node name="vcfindextabix" label="Index a VCF" 
	description="Index a VCF file with tabix"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	>
   <xi:include href="inport.vcf.xml"/>
   <outPort name="output" columns-at-runtime="true">
   </outPort>

  
	<property type="column" name="vcfInput" label="VCF path" description="VCF files" data-type="string"  port="input"/>
 	<property type="bool" name="noOverwrite" label="Do not overwrite if recent tbi file exists"  default="true"/>
  <code>
  <import>

import com.github.lindenb.jvarkit.util.vcf.VCFUtils;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import htsjdk.samtools.util.BlockCompressedInputStream;
import htsjdk.samtools.util.CloserUtil;
import htsjdk.samtools.util.LocationAware;
import htsjdk.tribble.BinaryFeatureCodec;
import htsjdk.tribble.Feature;
import htsjdk.tribble.FeatureCodecHeader;
import htsjdk.tribble.index.IndexFactory;
import htsjdk.tribble.index.tabix.TabixFormat;
import htsjdk.tribble.index.tabix.TabixIndex;
import htsjdk.tribble.readers.PositionalBufferedStream;
import htsjdk.tribble.util.TabixUtils;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.vcf.AbstractVCFCodec;


  </import>

<body><![CDATA[

	
	
	private static class BGZFCodec
		extends BinaryFeatureCodec<VariantContext> 
		{
		private AbstractVCFCodec delegate;
		BGZFCodec(AbstractVCFCodec delegate)
			{
			this.delegate=delegate;
			}
		
		@Override
		public boolean canDecode(String f) {
				return f.endsWith(".vcf.gz");
			}
		private String readLine(PositionalBufferedStream in)
			throws IOException
			{
			StringBuilder b=new StringBuilder();
			int c;
			while((c=in.read())!=-1 && c!='\n')
				{
				b.append((char)c);
				}
			return b.toString();
			}
		
		@Override
		public VariantContext decode(PositionalBufferedStream in)
			throws IOException {
			return delegate.decode(readLine(in));
			}
		@Override
		public Feature decodeLoc(PositionalBufferedStream in)
					throws IOException {
			return decode(in);
			}
		@Override
		public Class<VariantContext> getFeatureType() {
			return delegate.getFeatureType();
			}
		@Override
		public FeatureCodecHeader readHeader(PositionalBufferedStream in)
					throws IOException {
			String line=null;
			List<String> lines=new ArrayList<>();
			while((line=readLine(in))!=null)
				{
				if(!line.startsWith("#")) throw new IOException("Illegal VCF header "+line);
				lines.add(line);
				if(line.startsWith("#CHROM"))
					{
					return new FeatureCodecHeader(
							VCFUtils.parseHeader(lines).header,
							in.getPosition()
							);
					}
				}
			throw new IOException("Illegal VCF header. No #CHROM found");
			}
		
		@Override
		public LocationAware makeIndexableSourceFromStream(InputStream in)
			{
			if(in  instanceof BlockCompressedInputStream)
				{
				return BlockCompressedInputStream.class.cast(in);
				}
			return new BlockCompressedInputStream(in);
			}

		}	
	@Override
    protected BufferedDataTable[] execute(
    		final BufferedDataTable[] inData,
            final ExecutionContext exec
            ) throws Exception
			{
			BufferedDataContainer out_container =null;
			RowIterator rowiterator=null;
			final BGZFCodec codec =new BGZFCodec( VCFUtils.createDefaultVCFCodec());

			try
		    	{
				BufferedDataTable inTable=inData[0];
		        int inUriIndex = this.findVcfInputRequiredColumnIndex(inTable.getDataTableSpec());
		        double total=inTable.getRowCount();
		        int nRow = 0;
		        
	        	rowiterator=inTable.iterator();
	        	out_container = exec.createDataContainer(inTable.getDataTableSpec());
	        	
	        	while(rowiterator.hasNext())
	        		{
	        		++nRow;
	        		DataRow row=rowiterator.next();
	                DataCell cell =row.getCell(inUriIndex);

		            if(cell.isMissing())
		            	{
		            	getLogger().warn("Missing cells in "+getNodeName());
		            	continue;
		            	}
		            if(!cell.getType().equals(StringCell.TYPE))
		            	{
		            	getLogger().error("not a StringCell type in "+cell);
		            	continue;
		            	}
	                String pathname = StringCell.class.cast(cell).getStringValue();
	                if(pathname.isEmpty())
	                	{
		            	getLogger().error("Empty pathname");
		            	continue;
	                	}
	                File vcfFile= new File(pathname);
	                if(!vcfFile.exists() || !vcfFile.isFile() || !vcfFile.canRead())
	                	{
	                	getLogger().error("Cannot read VCF file: "+pathname);
		            	continue;
	                	}
	                if(!vcfFile.getName().endsWith(".vcf.gz"))
	                	{
	                	getLogger().error("File  "+pathname+" must end with vcf.gz");
		            	continue;
	                	}
	                File tbi =  new File(vcfFile.getParentFile(),vcfFile.getName()+TabixUtils.STANDARD_INDEX_EXTENSION);
	                if(this.isPropertyNoOverwriteValue() &&
	                	tbi.exists() &&
	                	tbi.lastModified()< vcfFile.lastModified())
	                	{
	                	getLogger().error("File  "+pathname+" already have tbi");
	                	}
	                else
	                	{
	                	getLogger().warn("Tabix for  "+pathname);
	                	
		                //http://sourceforge.net/p/samtools/mailman/message/32792441/
		                TabixIndex tbix = IndexFactory.createTabixIndex(
		                		vcfFile, codec, TabixFormat.VCF, null);
		                tbix.write(tbi);
	                	}
	                out_container.addRowToTable(row);
	                
	        		exec.checkCanceled();
	            	exec.setProgress(nRow/total,"Reading");
	        		}

		        /* create and fill array to be returned */
	        	out_container.close();
	            BufferedDataTable out0 = out_container.getTable();
	            out_container=null;
	            return new BufferedDataTable[]{out0};
		    	}
			catch(Exception err)
				{
				getLogger().error("Boum", err);
				err.printStackTrace();
				throw err;
				}
			finally
				{
				CloserUtil.close(out_container);
				}
			}


]]></body>
</code>
 
</node>

